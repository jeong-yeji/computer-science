# CPU

## CPU의 구성 요소

### ALU

- 레지스터로부터 **피연산자**를 받아들임

- 제어장치로부터 수행할 연산을 알려주는 **제어 신호**를 받아들임

- 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 **연산 수행**

- 레지스터로 **결과**(숫자, 문자, 주소)를 보냄

- 플래그 레지스터로 **플래그**를 보냄
  
  - 플래그(flag) : 연산 결과에 대한 부가 정보
  
  - 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그

### CU

- 제어장치는 **클럭 신호**를 받아들임

- 제어장치는 **해석해야 할 명령어**를 받아들임

- 제어장치는 **플래그 레지스터 속 플래그 값**을 받아들임

- 제어장치는 시스템 버스 중 **제어 버스로 전달된 제어 신호**를 받아들임

### Register

1. **프로그램 카운터 (PC; Program Counter)** : 메모리에서 가져올 명령어의 주소 저장

2. **명령어 레지스터 (IR; Instruction Register)** : 해석할 명령어를 저장하는 레지스터

3. **메모리 주소 레지스터 (MAR; Memory Address Register)** : 메모리의 주소를 저장하는 레지스터

4. **메모리 버퍼 레지스터 (MBR; Memory Buffer Register)** : 메모리와 주고 받을 값(데이터, 명령어)을 저장하는 레지스터

5. **플래그 레지스터 (flag register)** : 연산 결과나 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

6. **범용 레지스터 (general purpose register)**

7. **스택 포인터 (stack pointer)** : 레지스터를 이용한 주소 지정 방식 중 스택 주소 지정 방식에 사용
   
   - 스택 주소 지정 방식 (stack addressing mode)
     
     - 스택과 스택 포인터를 이용한 주소 지정 방식
     
     - 스택 포인터는 스택의 꼭대기(스택에 마지막으로 저장한 값의 위치)를 가리킴

8. **베이스 레지스터 (base register)** : 레지스터를 이용한 주소 지정 방식 중 변위 주소 지정 방식에 사용
   
   - 변위 주소 지정 방식 (displacement addressing mode)
     
     - 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더해 유효 주소를 얻어내는 주소 지정 방식
     
     - 변위 주소 지정 방식을 사용하는 명령어 = 연산 코드 + 레지스터 + 오퍼랜드
     
     - 상대 주소 지정 방식 (relative addressing mode) : 오퍼랜드 + 프로그램 카운터
     
     - 베이스 레지스터 주소 지정 방식 (base-register addressing mode) : 오퍼랜드 + 베이스 레지스터

## 명령어 사이클

- 명령어 사이클(instruction cycle) : CPU는 프로그램 속 명령어가 실행되는 주기
  
  - 인출 사이클(fetch cycle) : 메모리의 명령어를 CPU로 가져오는 과정
  
  - 실행 사이클(execution cycle) : CPU로 가져온 명령어를 실행하는 단계
  
  - 간접 사이클(indirect cycle) : 인출한 명령어를 바로 실행할 수 없어 추가로 메모리 접근이 필요한 경우
  
  - 인터럽트 사이클(interrupt cycle)

## 인터럽트

- **동기 인터럽트(synchronous interrupts)**
  
  - **CPU**에 의해 발생하는 인터럽트
  
  - 예외(exception)라고도 함
  
  - 폴트(falut), 트랩(trap), 중단(abort), 소프트웨어 인터럽트(software interrupt)로 구분됨

- **비동기 인터럽트(asynchronous interrupts)**
  
  - 주로 **입출력장치**에 의해 발생하는 인터럽트
  
  - 입출력 작업 중에도 효율적으로 명령어를 처리하기 위해 사용
  
  - 하드웨어 인터럽트(hardware interrupts)라고도 함
  
  - Maskable Interrupt와 Non Maskable Interrupt로 구분됨
  
  - 처리 순서
    
    1. 입출력 장치는 CPU에 인터럽트 요청 신호를 보냄
       
       - 인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트에 대한 요청
    
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함
    
    3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인함
       
       - 인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지 결정하는 플래그. NMI는 막을 수 없음
    
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업 백업
    
    5. CPU는 인터럽트 벡터를 참조해 인터럽트 서비스 루틴 실행
       
       - 인터럽트 벡터 : 각 인터를트를 구분하기 위한 정보로, 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
       
       - 인터럽트 서비스 루틴(ISR; Interrupt Service Routine) : 인터럽트를 처리하는 프로그램으로, 인터럽트를 처리하기 위한 동작으로 이루어진 프로그램
    
    6. 인터럽트 서비스 루틴이 끝나면 [4]에서 백업해둔 작업을 복구해 실행 재개

## CPU 설계 기법

- **코어(core)** : CPU 내에서 명령어를 실행하는 부품으로 한 CPU에 여러 개 있을 수 있음
  
  - 멀티코어 CPU(멀티코어 프로세서) : 여러 개의 코어를 포함하고 있는 CPU

- **스레드(thread)** : 실행 흐름의 단위
  
  - 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위
    
    - 하나의 코어가 여러 개의 명령어를 동시에 실행할 수 있음
    
    - 논리 프로세서(logical processor)라고도 함
    
    - 레지스터 세트 : 하나의 명령어를 실행하기 위해 필요한 레지스터
    
    - 멀티스레드 프로세서(멀티스레드 CPU) : 여러 개의 하드웨어적 스레드를 지원하는 CPU
  
  - 소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위

## 명령어 병렬 처리 기법

- 명령어 병령 처리 기법(ILP, Instruction-Level Parallelism)
  
  - 클럭 단위로 나눈 명령어 처리 단계
    
    1. 명령어 인출(Instruction Fetch)
    
    2. 명령어 해석(Instruction Decode)
    
    3. 명령어 실행(Execute Instruction)
    
    4. 결과 저장(Write Back)
  
  - 단계가 겹치지 않으면 CPU는 각 단계를 **동시에 실행**할 수 있음

- **명령어 파이프라이닝(instruction pipelining)**
  
  - 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
  
  - 파이프라인 위험(pipeline hazard)
    
    - 데이터 위험(data hazard) : 명령어 간 데이터 의존성에 의해 발생
    
    - 제어 위험(control hazard) : 주로 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
    
    - 구조적 위험(structural hazard) : 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하려고 할 때 발생

- **슈퍼스칼라(superscalar)**
  
  - 여러 개의 명령어 파이프라인을 두는 기법
  
  - 슈퍼스칼라 프로세서(슈퍼스칼라 CPU) : 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU

- **비순차적 명령어 처리(OoOE; Out-of-Order Execution)**
  
  - 파이프라인 중단 방지를 위해 명령어를 순차적으로만 처리하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하는 기법

## 명령어 집합 구조(ISA; Instruction Set Architecture)

- CPU가 이해할 수 있는 명령어들의 모음

- **CISC(Complex Instruction Set Computer)**
  
  - 복잡하고 다양한 명령어 집합을 활용하는 CPU
  
  - 장점
    
    - 다양하고 강력한 기능의 명령어 집합 활용
    
    - 명령어의 형태와 크기가 다양한 가변 길이 명령어 활용
    
    - 상대적으로 적은 수의 명령어로 프로그램 실행 가능
  
  - 단점
    
    - 명령어의 크기와 실행 시간이 일정하지 않음
    
    - 복잡한 명령어로 인해 명령어 하나를 실행하기 위해 여러 클럭 주기 필요
    
    - 명령어 파이프라이닝이 어려움
    
    - 대다수의 복잡한 명령어는 사용 빈도가 낮음

- **RISC(Reduced Instruction Set Complex)**
  
  - 단순하고 적은 수의 고정 길이 명령어 집합 사용
  
  - 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어 지향
  
  - 장점
    
    - 명령어 파이프라이닝에 유리
    
    - 메모리 접근 최소화 : load, store로 제한함
    
    - 레지스터를 많이 활용함 => 범용 레지스터의 개수가 더 많음
  
  - 단점
    
    - 프로그램 동작을 위해 더 많은 명령어 필요
