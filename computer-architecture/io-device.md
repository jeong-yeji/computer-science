# 입출력장치

## 장치 컨트롤러

입출력장치는 종류가 많고 데잉터 전송률이 낮아 컴퓨터에 직접 연결하여 데이터를 주고 받기 어려움 => **장치 컨트롤러** 사용

- 장치 컨트롤러의 역할
  
  - CPU와 입출력장치 간의 **통신 중개**
  
  - **오류 검출**
  
  - 데이터 **버퍼링** : 버퍼를 활용해 전송률이 차이나는 장치 간의 전송률 차이를 완화

- 장치 컨트롤러의 내부 구조
  
  - 데이터 레지스터(data register)
    
    - CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
    
    - 버퍼링에서 버퍼 역할을 함
    
    - 최근에는 레지스터 대신 RAM을 사용하기도 함
  
  - 상태 레지스터(status register)
    
    - 입출력장치가 입출력 작업을 할 준비가 되었는지
    
    - 입출력 작업이 완료되었는지
    
    - 입출력장치에 오류가 없는지
  
  - 제어 레지스터(control register)
    
    - 입출력장치가 수행할 내용에 대한 제어 정보와 명령 저장

## 장치 드라이버

- 장치 컨트롤러의 동작을 감지하고 제어해 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 **프로그램**

> 장치 컨트롤러 -> 하드웨어  //  장치 드라이버 -> 소프트웨어

## 프로그램 입출력(programmed I/O)

- 프로그램 속 명령어로 입출력장치(의 장치 컨트롤러)를 제어

- 과정
  
  1. CPU는 하드디스크 컨트롤러의 제어 레지스터에 쓰기 명령 전송
  
  2. 하드디스크 컨트롤러는 하드디스크 상태 확인 -> 상태 레지스터에 준비 완료 표시
  
  3. CPU는 상태 레지스터를 주기적으로 읽으며 하드디스크의 준비 여부 확인
  
  4. 하드디스크기 준비되면 백업할 메모리의 정보를 데이터 레지스트에 쓰기
  
  5. 위 과정 반복

. CPU가 장치 컨트롤러의 레지스터 값을 판단하는 방법에 따라 **메모리 맵 입출력**과 **고립형 입출력**으로 나눌 수 있음

. **메모리 맵 입출력(memory-mapped I/O)**

  . 메모리 접근을 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 **하나의 주소 공간**으로 간주하는 입출력 방식

  . 메모리 주소 공간이 입출력장치를 위한 주소 공간만큼 축소됨

  . CPU는 메모리의 주소나 장치 컨트롤러의 레지스터나 모두 똑같이 메모리 주소 대하듯이 대함 => 메모리 접근 명령어와 입출력장치 접근 명령어가 **같음**

. **고립형 입출력(isolated I/O)**

  . 메모리 접근를 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 **분리**하는 입출력 방식

  . 메모리 주소 공간이 축소되지 않음

  . 입출력 읽기/쓰기 선을 활성화시키기 위해 **입출력 전용 명령어** 사용

## 인터럽트 기반 입출력(Interrupt-Driven I/O)

1. CPU는 장치 컨트롤러에 입출력 작업을 명령함

2. 장치 컨트롤러는 입출력장치를 제어하며 입출력 작업을 수행하고, CPU는 다른 일을 함

3. 장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호 전송

4. CPU는 인터럽트를 받으면 하던 일을 백업하고 인터럽트 서비스 루틴을 실행함

=> 여러 입출력장치를 사용해 동시에 인터럽트가 발생한다면 어떻게 우선순위를 정할 것인가?

- **PIC(Programmable Interrupt Controller)**
  
  - 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에게 지금 처리해야 할 하드웨어 인터럽가 무엇인지 알려주는 장치
    
    - NMI(Non-Maskable Interrupt)는 우선순위가 가장 높아 판별이 불필요함
    
    - 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트만 판단함
  
  - 보통은 여러 PIC를 두고 사용함
  
  - 동작 과정
    
    1. PIC가 장치 컨트롤러에서 인터럽트 요청신호를 받아들임
    
    2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보냄
    
    3. CPU는 PIC에 인터럽트 확인 신호를 보냄
    
    4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보냄
    
    5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴을 실행함

## DMA 입출력

- 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 CPU의 부담 증가 => **DMA(DIrect Memory Access)** 사용

- DMA 입출력을 위해서는 시스템 버스에 연결된 **DMA 컨트롤러**가 필요함

- 동작 과정
  
  1. CPU는 DMA 컨트롤러에게 입출력 작업을 명령함
  
  2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업 수행
     
     - 입출력 작업 중 필요 시 DMA 컨트롤러가 메모리에 직접 접근해 정보를 읽고 씀
  
  3- 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림

- CPU는 입출력 작업의 시작과 끝에만 관여함

- 하지만 시스템 버스는 공용 자원이므로 CPU와 DMA 컨트롤러가 동시에 사용할 수 없음
  
  - cycle stealing : DMA의 시스템 버스 이용
  1. DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스를 이용
  
  2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용

- DMA가 시스템 버스를 자주 사용한다면 CPU가 이용 가능한 시간이 줄어듦 => **입출력 버스** 이용
