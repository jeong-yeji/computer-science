# 페이징을 통한 가상 메모리 관리

- 연속 메모리 할당 방식의 문제점
  
  - 외부 단편화
  
  - 물리 메모리보다 큰 프로세스 실행 불가

- **가상 메모리 (virtual memory)**
  
  - 실행하고자 하는 프로그램의 일부만 메모리에 적재해서 실제 물리 메모리보다 큰 프로세스를 실행할 수 있게 하는 기술
  
  - **paging** => 대부분 OS에서 사용
  
  - segmentation

## 페이징(paging)

- **프로세스의 논리 주소 공간**을 `page` 단위로 자르고, **메모리의 물리 주소 공간**을 `frame`이라는 페이지와 동일한 일정한 단위로 자른 뒤 **page를 frame에 할당**하는 가상 메모리 관리 기법

- 페이징에서의 스와핑
  
  - 페이지 단위로 swap-in(**page-in**) & swap-out(**page-out**)
  
  - 프로세스 실행을 위해 모든 페이지가 적재될 필요 없음!
  
  - => 물리 메모리보다 큰 프로세스 실행 가능

- 프로세스를 이루는 페이지가 적재된 프레임의 위치를 CPU가 알기 어려움 => **페이지 테이블** 사용

## 페이지 테이블

- 페이지 번호와 프레임 번호를 매칭해줌

- **물리 주소에 불연속적**으로 배치되더라도 **논리 주소에는 연속적**으로 배치되도록 하는 방법 => CPU는 논리 주소를 순차적으로 실행하면 됨

- 각 프로세스마다 페이지 테이블을 가짐

- 내부 단편화(internal fragmentation)
  
  - 페이징에서 발생할 수 있는 부작용
  
  - 프로세스의 마지막 페이지에서 페이지 크기보다 작은 크기가 낭비될 수 있음
  
  - 메모리 낭비의 크기가 외부 단편화보다 작은 경우가 많음

- `getconf PAGESIZE` : 페이지 크기를 확인하는 명령어
  
  - 모든 페이지가 같은 크기를 가지는 것은 아님
  
  - e.g., 대형 페이지 (huge page)

- **프로세스 테이블 베이스 레지스터(PTBR; Process Table Base Register)**
  
  - 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴

- 페이지 테이블이 메모리에 있으면 메모리 접근 시간이 2배로 늘어남 => TLB
  
  - cpu -> page table + cpu -> frame(page)

- **TLB(Translation Lookaside Buffer)**
  
  - 페이지 테이블의 일부를 저장하는 캐시 메모리
  
  - 불필요한 메모리 접근을 줄임
  
  - TLB hit/miss

## 페이징에서의 주소 변환

- 특정 주소에 접근하기 위해 필요한 정보
  
  - 접근하고자 하는 **페이지/프레임의 정보**
  
  - 한 페이지/프레임은 여러 주소를 포괄함 => 접근하고자 하는 주소가 페이지/프레임에서 **얼마나 떨어져 있는지**
  
  - *e.g., 프로세스 A의 페이지 2에서 10만큼 떨어진 주소에 접근*

- **페이징 시스템의 논리 주소 = 페이지 번호(page number) + 변위(offset)**

- **논리 주소 (페이지 번호, 변위)**  <- 페이지 테이블 -> **물리 주소 (프레임 번호, 변위)**
  
  - 논리 주소의 변위 == 물리 주소의 변위

## 페이지 테이블 엔트리(PTE; Page Table Entry)

- 페이지 테이블의 각 행

- PTE의 구성 요소 *(OS마다 다름)*
  
  - **페이지 번호**
  
  - **프레임 번호**
  
  - **유효 비트(valid bit)** : 현재 해당 페이지에 **접근 가능**한지 여부
    
    - `1` : 메모리에 적재된 페이지 -> **메모리**에 적재됨
    
    - `0` : 메모리에 적재되지 않은 페이지 -> **스왑 영역**
      
      - 유효 비트가 0인 페이지에 접근하려고 하면 **페이지 폴트(page fault) 인터럽트** 발생
        
        1. CPU는 기존 작업 내역 백업
        
        2. 페이지 폴트 처리 루틴 실행
        
        3. 페이지 폴트 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
        
        4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근 가능
  
  - **보호 비트(protection bit)** : **페이지 접근 권한**을 제한해 페이지를 보호하는 비트
    
    - `1` : 읽기/쓰기 페이지
    
    - `0` : 읽기 전용 페이지
    
    - rwx로 나눠서 3비트로 저장할 수도 있음
  
  - **참조 비트(reference bit)** : CPU가 페이지에 접근한 적이 있는지 여부 저장
    
    - `1` / `0` : 접근한 적 있음/없음
  
  - **수정 비트(dirty bit, modified bit)** : CPU가 페이지에 데이터를 쓴 적이 있는지 여부 저장
    
    - `1` `0` : 변경된 적 있음/없음
    
    - **swap-out 시** 보조기억장치에 **쓰기 작업**을 해야하는지 판단하기 위해 사용


